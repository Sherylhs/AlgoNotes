# Table of Contents
- [考点](#考点)
- [遍历](#遍历)
- [分治](#分治)
- [方式](#方式)
- [Binary Search Tree](#binary-search-tree)


二叉树 (Binary Tree) 有 _分治法_（Divide & Conquer）与 _遍历法_（Traverse）两种常见的递归（Recursion）方法。

## 考点
第一类考察形态: 求值、求路径类
第二类考察形态: 结构变化类
第三类考察形态: 二叉查找树


## 遍历
### 定义
- 层序遍历(Level Order): 使用BFS获得二叉树的分层信息，也可以称之为BFS Order。
- 先序遍历(Pre-Order):首先访问根结点，然后遍历左子树，最后遍历右子树。遍历左、右子树时，仍按先序遍历。若二叉树为空则返回。该过程可简记为 __根左右__。
- 中序遍历(In-Order): 首先遍历左子树，然后访问根结点，最后遍历右子树。遍历左、右子树时，仍按中序遍历。若二叉树为空则返回。简记为 __左根右__。
- 后序遍历(Post-Order): 首先遍历左子树，然后遍历右子树，最后访问根结点。遍历左、右子树时，仍按后序遍历。若二叉树为空则返回。简记为 __左右根__。

假设一棵二叉树的层序遍历是ABCDEFG，则:
- 先序遍历: ABDECF
- 中序遍历: DBEAFC
- 后序遍历: DEBFCA

### 思路
通过前序/中序/后序的某种遍历，游走整棵树，通过一个全局变量或者传递的参数来记录这个过程中所遇到的点和需要计算的结果。

### 非递归实现
Pre-Order(根、左、右):
1. 如果根节点非空，将根节点加入到栈中。
2. 如果栈不空，弹出出栈顶节点，将其值加加入到数组中。
    - 如果该节点的右子树不为空，将右子节点加入栈中。
    - 如果左子节点不为空，将左子节点加入栈中。
3. 重复第二步，直到栈空。

In-Order(左、根、右):
1. 如果根节点非空，将根节点加入到栈中。
2. 如果栈不空，取栈顶元素（暂时不弹出），
    - 如果左子树已访问过，或者左子树为空，则弹出栈顶节点，将其值加入数组，如有右子树，将右子节点加入栈中。
    - 如果左子树不为空，则将左子节点加入栈中。
重复第二步，直到栈空。

Post-Order(左、右、根):
1. 如果根节点非空，将根节点加入到栈中。
2. 如果栈不空，取栈顶元素（暂时不弹出），
    - 如果（左子树已访问过或者左子树为空），且（右子树已访问过或右子树为空），则弹出栈顶节点，将其值加入数组，
    - 如果左子树不为空，切未访问过，则将左子节点加入栈中，并标左子树已访问过。
    - 如果右子树不为空，切未访问过，则将右子节点加入栈中，并标右子树已访问过。
3. 重复第二步，直到栈空。


## 分治
### 定义
分治法（Divide & Conquer Algorithm）是说将一个大问题，拆分为2个或者多个小问题，当小问题得到结果之后，合并他们的结果来得到大问题的结果。
在一棵二叉树（Binary Tree）中，如果将整棵二叉树看做一个大问题的话，那么根节点（Root）的左子树（Left subtree）就是一个小问题，右子树（Right subtree）是另外一个小问题。这是一个天然就帮你完成了“分”这个步骤的数据结构。

### 思路
先让左右子树去解决同样的问题，然后得到结果之后，再整合为整棵树的结果。从程序实现角度，分治法的递归函数通常有一个返回值，遍历法通常没有。


## 方式
### 搜索(Search)
搜索分为深度优先搜索（Depth First Search）和宽度优先搜索（Breadth First Search），通常分别简写为 DFS 和 BFS。搜索是一种类似于枚举（Enumerate）的算法。

枚举法通常是知道循环的范围，然后可以用几重循环就搞定的算法。比如需要找到所有 x^2 + y^2 = K 的整数组合，可以使用两重循环的枚举法。

而问题如求 N 个数的全排列，可能需要用 N 重循环才能解决。这个时候，就倾向于采用递归的方式去实现这个变化的 N 重循环。这个算法便称之为搜索，因为已经不能明确写出一个不依赖于输入数据的多重循环。

通常来说 DFS 会采用递归的方式实现，而 BFS 则无需递归（使用队列 Queue + 哈希表 HashMap）。在面试中，如果一个问题既可以使用 DFS，又可以使用 BFS 的情况下，一定要优先使用 BFS。因为BFS是非递归的，且更容易实现。

### 回溯(Backtracking)
有时深度优先搜索算法（DFS），又被称之为回溯法，所以可以完全认为回溯法，就是深度优先搜索算法。回溯实际上是深度优先搜索过程中的一个步骤。比如在进行全子集问题的搜索时，假如当前的集合是 {1,2} 代表正在寻找以 {1,2}开头的所有集合。那么下一步，会去寻找 {1,2,3}开头的所有集合，然后当我们找完所有以 {1,2,3} 开头的集合时，需要把 3 从集合中删掉，回到 {1,2}。然后再把 4 放进去，寻找以 {1,2,4} 开头的所有集合。这个把 3 删掉回到 {1,2} 的过程，就是回溯。

### 递归(Recursion)
递归包含两个层面的意思：
1. 一种由大化小，由小化无的解决问题的算法。类似的算法还有动态规划（Dynamic Programming）。
2. 一种程序的实现方式。这种方式就是一个函数（Function / Method / Procedure）自己调用自己。

与之对应的，有非递归（Non-Recursion）和迭代法（Iteration），可以认为这两个概念是一样的概念（番茄和西红柿的区别），不需要做区分。

递归的三要素：
1. 定义 - 每一个递归函数，都需要有明确的定义，有了正确的定义以后，才能够对递归进行拆解。
2. 拆解 - 一个大问题如何拆解为若干个小问题去解决。
3. 出口 - 什么时候可以直接知道答案，不用再拆解，直接return。


## Binary Search Tree
### 定义
二叉搜索树（Binary Search Tree，又名排序二叉树，二叉查找树，通常简写为BST）定义如下：
空树或是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有节点值均小于或等于它的根节点值；
（2）若右子树不空，则右子树上所有节点值均大于根节点值；
（3）左、右子树也为二叉搜索树；

### 特性
- 按照中序遍历（In-Order Traversal）打印各节点，会得到由小到大的顺序。
- 在BST中搜索某值的平均情况下复杂度为O(logN)，最坏情况下复杂度为O(N)，其中N为节点个数。将待寻值与节点值比较，若不相等，则通过是小于还是大于，可断定该值只可能在左子树还是右子树，继续向该子树搜索。
- 在Balanced BST中查找某值的时间复杂度为O(logN)。

### 作用
- 通过中序遍历，可快速得到升序节点列表。
- 在BST中查找元素，平均情况下时间复杂度是O(logN)；插入新节点，保持BST特性平均情况下要耗时O(logN)。
和有序数组的对比：有序数组查找某元素可以用二分法，时间复杂度是O(logN)；但是插入新元素，维护数组有序性要耗时O(N)。

### AVL
平衡二叉搜索树（Balanced Binary Search Tree，又称为AVL树，有别于AVL算法）是二叉树中的一种特殊的形态。二叉树当且仅当满足如下两个条件之一，是平衡二叉树：
- 空树
- 左右子树高度差绝对值不超过1且左右子树都是平衡二叉树

当AVL树有N个节点时，高度为O(logN)。设想一棵满二叉树，每个节点左右子树高度相同，随着树高的增加，叶子容量指数暴增，树高一定为O(logN)。而相比于满二叉树，AVL树仅放宽一个条件，允许左右两子树高度差1，当树高足够大时，可以把1忽略。因为树不可能太稀疏。严格的数学证明复杂,略去。而普通树的高度不为O(longN)，因为最坏情况下，单枝扩展的树高为O(N)。

