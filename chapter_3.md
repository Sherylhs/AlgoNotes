# Table of Contents
- [Complexity](#complexity)
    - [Time](#time)
        - [T函数推导法](#t函数推导法)
            - [Example](#example)
        - [通用公式](#通用公式)
        - [Exercise](#exercise)
        - [Explanation](#explanation)
    - [Space](#space)
        - [Example](#example-1)
- [Stack & Heap](#stack-&-heap)


# Complexity
## Time
在计算机科学中，时间复杂度使用标记O(大写英文字母o)表示，只包含上述多项式中的最高次项，且忽略最高次项的系数。

时间复杂度计算的要点：
- 只包含多项式的最高次项。 这是因为在复杂度计算中，最高次项对运行时间有决定性的作用，次高次项可以忽略不计。例如f(n) = n<sup>2</sup> + n， 此时n这一项对于多项式的值的影响相对于n<sup>2</sup>可以忽略不计。在定性的描述中，我们只取最高次项。
- 不包含多项式最高次项的系数。 对于最高次项，我们忽略它的系数，在算法中，我们称之为常数。上面代码中，常数是2,但是时间复杂度的计算，我们只取O(n)。

| 复杂度 | 可能对应的算法 | 备注 |
| ----- | ----- | ----- |
| O(1) | 位运算 | 常数级复杂度，一般面试中不会有 |
| O(logn) | 二分法，倍增法，快速幂算法，辗转相除法 |  |
| O(n) | 枚举法，双指针算法，单调栈算法，KMP算法，Rabin Karp，Manacher's Algorithm | 又称作线性时间复杂度 |
| O(nlogn) | 快速排序，归并排序，堆排序 |  |
| O(n<sup>2</sup>) | 数组，枚举法，动态规划，Dijkstra |  |
| O(n<sup>3</sup>) | 数组，枚举法，动态规划，Floyd |  |
| O(2<sup>n</sup>) | 与组合有关的搜索问题 | 非多项式时间复杂度 - NP问题 |
| O(n!) | 与排列有关的搜索问题 | 非多项式时间复杂度 - NP问题 |

### T函数推导法
二分法是每次通过 O(1) 的时间将规模为n的问题降低为规模为n/2的问题。这里我们用 T(n) 来表示规模为n的问题在该算法下的时间复杂度，得出推导公式：`T(n) = T(n/2) + O(1)`

首先 T 代表的是Time Complexity, n代表的是问题规模（二分法里就是数组的大小）。
那么 T(n) 代表的就是：__求处理问题规模为n的数据的时间复杂度是多少__。注意这里是一个问句，不是一个答案。 T(n) 根据算法的不同可以是 O(n) 也可以是 O(nlogn) 或任何值，而 O(n) 就是 O(n)。

在时间复杂度的领域里，有如下的一些性质：
- `T(1) = O(1)` // 解决规模为1的问题通常时间复杂度为O(1)。这个不100%对，但是99.9%的情况下都是如此。
- `k * O(n) = O(kn)`
- `O(n) + O(m) = O(n + m)`

采用 T 函数展开的方法，将二分法的时间复杂度最终转换为用 O(...) 来表示:
```
T(n) = T(n/2) + O(1)
     = T(n/4) + O(1) + O(1)
     = T(n/8) + O(1) * 3
     = T(n/16) + O(1) * 4
     ...
     = T(1) + O(1) * logn
     = O(logn)
```

#### Example
1. 求以下算法的时间复杂度：
```
while (n > 1) {
   这里执行一个使用 O(n) 的算法，将 n 的规模缩小一半
   n = n / 2
}
```
解答：
根据算法，用T函数推导法写出公式：`T(n) = T(n/2) + O(n)`

推导过程如下：
```
T(n) = T(n/2) + O(n)
     = T(n/4) + O(n/2) + O(n)
     = T(n/8) + O(n/4) + O(n/2) + O(n)
     = ...
     = O(1) + O(2) + ... O(n/2) + O(n)
     = O(1 + 2 + 4 .. + n/2 + n)
     = O(2n) = O(n)
```
认为这个式子的结果是 O(nlogn)，这是错误的。主要错在，当 T(n/2) 往下继续展开的时候，直接写成 T(n/4) + O(n) 是不对的。而应该是 T(n/4) + O(n/2)。这里不能约掉 O(n/2) 里的 /2，以免误差累积。

另外一个需要记住的结论就是：`O(1 + 2 + 4 ... + n/2 + n) = O(n)`。这个结论可以通过简单的将 n = 1024 带入计算可以得到：

`1 + 2 + 4 + ... + 1024 = 2047 ~ 2 * 1024 = O(2n) = O(n)`

2. 请用 T 函数来推导归并排序算法的时间复杂度

解答：归并排序算法的步骤为：

    1. 找出数组的中点
    2. 将数组分成两个部分递归执行该算法，分别排序两个部分
    3. 合并两个排序好的子数组到一个大数组

写成 T 函数为：T(n) = 2*T(n/2) + O(n)，其中
- 2*T(n/2)2∗T(n/2) 代表将 n 的问题，拆分为两个 n/2 的同类问题去进行处理。
- O(n) 代表了，合并两个排好序的 n/2 大小的数组的时间复杂度。

我们用展开的方式推导该算法下的 T(n):
```
T(n) = 2 * T(n/2) + O(n)
     = 2 * (2 * T(n/4) + O(n/2)) + O(n)
     = 4 * T(n/4) + 2 * O(n/2) + O(n)
     = 4 * T(n/4) + 2 * O(n)
     = 4 * (2 * T(n/8) + O(n/4)) + 2 * O(n)
     = 8 * T(n/8) + 3 * O(n)
     = 16 * T(n/16) + 4 * O(n)
     ...
     = n * T(1) + logn * O(n)
     = O(n) + O(nlogn)
     = O(nlogn)
```

3. 如果一个算法，每次通过 O(1) 的时间将 n 的问题拆分为两个 n/2 的问题，求时间复杂度。

解答：首先写出推导函数：T(n) = 2 * T(n/2) + O(1)，然后进行推导：
```
T(n) = 2 * T(n/2) + O(1)
     = 2 * (2 * T(n/4) + O(1)) + O(1)
     = 4 * T(n/4) + O(2 + 1)
     = 8 * T(n/8) + O(4 + 2 + 1)
     ...
     = n * T(1) + O(n/2 + n/4 + ... + 2 + 1)
     = O(n) + O(n)
     = O(n)
```
结果与例子1类似。

### 通用公式
- 搜索的时间复杂度：O(答案总数 * 构造每个答案的时间)
    - Subsets 问题: 求所有的子集。子集个数一共 2^n，每个集合的平均长度是 O(n) 的，所以时间复杂度为 O(n * 2^n)
    - 同理 Permutations 问题: 时间复杂度为：O(n * n!)
- 动态规划的时间复杂度：O(状态总数 * 计算每个状态的时间复杂度)
    - Triangle，数字三角形的最短路径: 状态总数约 O(n^2) 个，计算每个状态的时间复杂度为 O(1) —— 就是求一下 min, 所以总的时间复杂度为 O(n^2)
- 用分治法解决二叉树问题的时间复杂度：O(二叉树节点个数 * 每个节点的计算时间)
    - 二叉树最大深度: 二叉树节点个数为 N，每个节点上的计算时间为 O(1)。总的时间复杂度为 O(N)

### Exercise
```py
# 1
sum = 0
i = 0
while i < n:
    sum += 1
    i *= 2

# 2
sum = 0
for i in range(n):
    j = 1
    while j <= n:
        sum += 1
        j *= 2

# 3
def Fibo(n):
    if n == 0 or n == 1:
        return 1
    return Fibo(n-1) + Fibo(n-2)

# 4
F = [0] * 50
F[0] = F[1] = 1

def Fibo(n):
    if F[n] != 0:
        return F[n]
    F[n] = Fibo(n-1) + Fibo(n-2)
    return F[n]

# 5
sum = 0
for i in range(n):
    for j in range(i, n):
        sum += 1

# 6
j = 0
for i in range(0, n):
    while j < n and nums[j]-nums[i] < window:
        j += 1
```

### Explanation
1. O(logn)
2. O(nlogn)
3. O(2<sup>n/2</sup>) ~ O(2<sup>n</sup>)
- 时间复杂度上界：Fibo(n) = Fibo(n-1) + Fibo(n-2) < 2 * Fibo(n-1)，
也就是说，递归版 Fibonacci 的时间复杂度 < T(n) = 2 * T(n-1) + O(1) = O(2<sup>n</sup>)
- 时间复杂度下界：Fibo(n) = Fibo(n-1) + Fibo(n-2) > 2 * Fibo(n-2)，
也就是说，递归版 Fibonacci 的时间复杂度 > T(n) = 2 * T(n-2) + O(1) = O(2<sup>n/2</sup>)
4. O(n)
5. O(n<sup>2</sup>)
- 累加所有的执行次数，一共执行了(n + n-1 + n-2 ... + 1) = (1 + n) * n / 2次
6. O(n)
- 这个程序是典型的双指针算法，[i, j) 是一个滑动窗口的两端，滑动窗口之内的数，两两之差 < window。数循环次数是一个偷懒的时间复杂度计算方法，却不是最准确的时间复杂度计算方法。时间复杂度的定义，是程序总共执行的语句数目的数量级。
- 在这个代码中，执行次数最多的是 j++ 这个循环主体。而这个循环体不会被执行 O(n^<sup>2</sup>)次，因为 j 在每次 i 循环的时候，不会被重置到 i 或者 0 的位置开始重新计算。j一直是自顾自的单向递增，那么一旦某一次 while 循环使得 j++ 执行了 n 次以后，while 循环就再也进不去了。因此总共的执行次数是O(n + n) = O(n) 而不是 O(n * n)。


## Space
Note that the space cost doesn't include the space used for input and output.

算法所占用的空间主要有三个方面：_算法代码本身占用的空间_、_输入输出数据占用的空间_、_算法运行时临时占用的空间_。

其中，代码本身和输入输出数据占用的空间不是算法空间复杂度考虑的范围内，空间复杂度只考虑运行时临时占用的空间，又称为算法的额外空间（Extra space）。

临时占用的空间包括：
- 为参数列表中形参变量分配的空间
- 为函数体中局部变量分配的空间

如果是递归函数，需要将上述两部分占用空间的和乘以递归的深度，这是堆栈空间。在递归函数中，除了变量和数组所开辟的临时空间以外，还有一个空间我们需要纳入考虑，就是递归时占用的栈空间（Stack）。

递归函数需要保存当前的环境，以便在递归返回的时候能够还原之前的现场。因此递归的深度越深，所要占用的栈空间越大。当空间超出一定范围的时候就会出现程序爆栈（Stack Overflow）的情况。

累加下面两个部分的内容即是代码的空间复杂度：
- 代码里开辟了多少新的空间（new 了多少新的内容出来）
- 递归深度 * 递归函数内部的参数和局部变量所占用的空间

### Example
快速排序的思路如下：
1. 选择一个基准元素，将原数组分为两部分，左边部分小于该元素，右边部分大于该元素。
2. 分别递归处理左边和右边。

- 最好情况：
每次都能恰好将数组分成左右相同长度的两部分，需要的递归深度是:logn，每次将数组分成两部分时，我们选择不使用辅助数组，在原数组上“就地”处理，所以每层的空间是O(1)。因此总的复杂度是: __O(logn)__

- 最差情况：
每次都将数组分成长度差最大的两部分，即一边只有一个元素，其余的在另外一边，最大深度为：n， 因此空间复杂度为: __O(n)__。

有些递归算法的空间复杂度是稳定的，不会退化，快排的递归深度与其每次选择的“基准值”有很大关系，因此存在退化的情况。

在面试中常见算法的空间复杂度：
- 快速排序： 最优：O(logn)，最差:O(n)
- 二分查找： O(1)
- 最短路(Dijkstra)算法： O(V)(V表示点集大小)


# Stack & Heap
通常所说的内存空间，包含了两个部分：栈空间（Stack space）和堆空间（Heap space）

当一个程序在执行的时候，操作系统为了让进程可以使用一些固定的不被其他进程侵占的空间用于进行函数调用，递归等操作，会开辟一个固定大小的空间（比如 8M）给一个进程使用。这个空间不会太大，否则内存的利用率就很低。这个空间就是栈空间，Stack space。

通常所说的栈溢出（Stack Overflow）是指在函数调用，或者递归调用的时候，开辟了过多的内存，超过了操作系统余留的那个很小的固定空间导致的。栈空间主要包含如下两个部分：
- 函数的参数与返回值
- 函数的局部变量

```python
def f(n):
    nums = [0] * n  # 相当于Java中的new int[n]
    sum = 0
    for i in range(n):
        nums[i] = i
        sum += i
    return sum
```

根据定义，参数`n`、最后的函数返回值`f`、局部变量`sum`都可以确认是放在栈空间里的，而nums则不然。
此处 nums 可以理解为两个部分：
- 一个名字叫做`nums`的局部变量，存储了指向内存空间的一个地址（Reference），这个地址也就是 4 个字节（32位地址总线的计算机，地址大小为 4 字节）
- new 出来的，一共有n个位置的整数数组，int[n]。共占用4 * n个字节。

`nums`该变量本身因为是一个局部变量，是存储在栈空间的。但是`nums`里存储的n个整数，是存储在堆空间(Heap space)里的， 所以它们不占用栈空间，并不会导致栈溢出。

在大多数的编程语言中，特别是 Java, Python 这样的语言中，万物皆对象，基本上每个变量都包含了变量自己和变量所指向的内存空间两个部分的逻辑含义。

```python
def copy(nums):
    arr = [0] * len(nums)
		for i in range(len(nums)):
        arr[i] = nums[i]
    return arr
		
# 使用list comprehension实现同样功能
def copy(nums):
    arr = [x for x in nums]
    return arr

if __name__ == "__main__":
    nums = [0]*10
    nums[0] = 1
    new_nums = copy(nums)
```

在`copy()`这个函数中，`arr`是一个局部变量，他在`copy()`函数执行结束之后就会被销毁。但是里面new出来的新数组并不会被销毁。这样，在main函数里，`new_nums`里才会有被复制后的数组。所以可以发现一个特点：__栈空间里存储的内容，会在函数执行结束的时候被撤回__。

简而言之可以这么区别栈空间和堆空间：`new 出来的就放在堆空间，其他都是栈空间`。

## 递归深度
递归深度就是递归函数在内存中，同时存在的最大次数。一般来说，关心更多的是递归深度的数量级。普通阶乘函数（如`f(n) = f(n-1) * n`）的递归深度是O(n)，而在二分查找中，递归深度则是O(log(n)。

### 内存溢出
首先，函数本身也是在内存中占空间的，主要用于存储传递的参数，以及调用代码的返回地址。

函数的调用，会在内存的栈空间中开辟新空间，来存放子函数。递归函数更是会不断占用栈空间，例如阶乘函数`f(n) = f(n-1) * n`，展开到最后`n = 1`时，内存中会存在f(100)、f(99)、f(98) ... f(1)这些函数，它们从栈底向栈顶方向不断扩展。

当递归过深时，栈空间会被耗尽，这时就无法开辟新的函数，会报出 __stack overflow__ 这样的错误。 所以，在考虑空间复杂度时，递归函数的深度也是要考虑进去的。

### tail recursion
若递归函数中，递归调用是整个函数体中最后的语句，且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。（`f(n) = f(n-1) * n`满足前者，但不满足后者，故不是尾递归函数）

尾递归函数的特点是：在递归展开后该函数不再做任何操作，这意味着该函数可以不等子函数执行完，自己直接销毁，这样就不再占用内存。一个递归深度O(n)的尾递归函数，可以做到只占用O(1)空间。这极大的优化了栈空间的利用。

但要注意，这种内存优化是由编译器决定是否要采取的，不过大多数现代的编译器会利用这种特点自动生成优化的代码。在实际工作当中，尽量写尾递归函数，是很好的习惯。

```python
def f(n):
    if n <= 0:
        return 0
    return f_tail(n, 1)

def f_tail(n, a):
    if n == 1:
        return a
    else:
        return f_tail(n - 1, n * a)
```

